<!DOCTYPE html>
<html>
<head>
    <title>Ã‰diteur de Cartes 2.5D</title>
    <!-- In a real project, link to an external stylesheet: <link rel="stylesheet" href="styles.css"> -->
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: sans-serif;
            overflow: hidden;
            background-color: #333;
            color: #fff;
        }

        .editor-container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .sidebar {
            width: 250px;
            background-color: #2a2a2a;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        #left-sidebar {
            border-right: 1px solid #444;
        }

        #right-sidebar {
            border-left: 1px solid #444;
        }

        #map-canvas-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1e1e1e;
        }

        #map-canvas {
            background-color: #fff;
            border: 1px solid #555;
        }

        h3 {
            color: #eee;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            margin-top: 0; /* Added to prevent extra space at the top of panels */
        }

        #object-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
            gap: 10px;
            margin-top: 10px; /* Added space below the h3 */
        }

        .palette-object {
            width: 100%;
            height: auto;
            object-fit: cover;
            border: 2px solid transparent;
            cursor: pointer;
            background-color: #444;
            padding: 5px;
            box-sizing: border-box;
            image-rendering: pixelated; /* Helps with pixel art scaling */
            display: block; /* Ensure image doesn't have default bottom space */
        }

        .palette-object:hover {
            border-color: #777;
        }

        .palette-object.selected {
            border-color: #00aaff;
            background-color: #555;
        }

        #inspector-panel p {
            margin: 10px 0;
        }

        #delete-object-btn {
            background-color: #c0392b;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px; /* Added space above the button */
        }

        #delete-object-btn:hover {
            background-color: #e74c3c;
        }

        #tools-panel button {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background-color: #444;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }

        #tools-panel button:hover {
            background-color: #555;
        }

        /* Added some basic layout to the tools and objects panels */
        #tools-panel, #objects-panel, #inspector-panel {
             margin-bottom: 20px; /* Space between panels */
             /* Flex properties for sidebar content */
             flex-shrink: 0; /* Prevent shrinking */
             flex-grow: 0; /* Don't grow */
             /* Or, if you want panels to distribute space and allow #object-list to scroll: */
             /* flex-basis: auto; */
        }

        /* Ensure #object-list takes available space to allow scrolling within its parent panel */
        #objects-panel #object-list {
             flex-grow: 1;
             overflow-y: auto; /* Make the object list scrollable */
        }


    </style>
</head>
<body>
    <div class="editor-container">
        <div id="left-sidebar" class="sidebar">
            <div id="tools-panel">
                <h3>Tools</h3>
                <button id="save-btn">Save Map</button>
                <input type="file" id="load-input" accept=".map" style="display: none;">
                <button id="load-btn">Load Map</button>
                <!-- Add other tools here -->
            </div>
            <div id="objects-panel">
                <h3>Map Objects</h3>
                <div id="object-list">
                    <!-- Object previews will go here, generated by JS -->
                </div>
            </div>
        </div>
        <div id="map-canvas-container">
            <canvas id="map-canvas"></canvas>
        </div>
        <div id="right-sidebar" class="sidebar">
            <div id="inspector-panel">
                <h3>Inspector</h3>
                <!-- Inspector content will go here, updated by JS -->
                <p>No object selected.</p>
            </div>
            <!-- Add other inspector panels or properties here -->
        </div>
    </div>

    <!-- In a real project, link to an external script file: <script src="Script.js"></script> -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('map-canvas');
            const ctx = canvas.getContext('2d');

            // Set initial canvas size - Consider making this responsive
            canvas.width = 800;
            canvas.height = 600;

            const TILE_SIZE = 32;

            const camera = {
                x: 0,
                y: 0,
                zoom: 1
            };

            // --- Drawing Functions ---

            function drawGrid() {
                // Adjust line width for current zoom level
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1 / camera.zoom;

                // Calculate visible area in world coordinates
                const worldVisibleWidth = canvas.width / camera.zoom;
                const worldVisibleHeight = canvas.height / camera.zoom;

                const startX = Math.floor(camera.x / TILE_SIZE) * TILE_SIZE;
                const startY = Math.floor(camera.y / TILE_SIZE) * TILE_SIZE;

                const endX = camera.x + worldVisibleWidth + TILE_SIZE; // Add TILE_SIZE to ensure last line is drawn
                const endY = camera.y + worldVisibleHeight + TILE_SIZE; // Add TILE_SIZE

                // Draw vertical lines
                for (let x = startX; x < endX; x += TILE_SIZE) {
                    ctx.beginPath();
                    // Translate world coordinates to canvas coordinates for drawing
                    const screenX = x - camera.x;
                    ctx.moveTo(screenX, 0); // Draw across the entire canvas height in screen space
                    ctx.lineTo(screenX, canvas.height / camera.zoom); // Need to be careful with coordinate spaces here
                    ctx.stroke();
                }

                // Draw horizontal lines
                for (let y = startY; y < endY; y += TILE_SIZE) {
                    ctx.beginPath();
                     // Translate world coordinates to canvas coordinates for drawing
                    const screenY = y - camera.y;
                    ctx.moveTo(0, screenY); // Draw across the entire canvas width in screen space
                    ctx.lineTo(canvas.width / camera.zoom, screenY); // Need to be careful with coordinate spaces here
                    ctx.stroke();
                }
                 // --- Correction/Refinement for Grid Drawing ---
                 // The previous grid drawing coordinates might be slightly off due to mixing world/screen space.
                 // Let's rethink the grid drawing within the transformed context.
                 // With the canvas context already transformed by translate(-camera.x, -camera.y) and scale(zoom, zoom),
                 // drawing at world coordinates (x, y) will appear at the correct spot on screen.
                 // We just need to calculate the *range* of world coordinates visible and draw lines within that range.

                 ctx.strokeStyle = '#ccc';
                 ctx.lineWidth = 1 / camera.zoom; // Line width must be scaled inverse to zoom

                 // Calculate the top-left corner of the currently visible world area
                 const worldViewLeft = camera.x;
                 const worldViewTop = camera.y;
                 const worldViewRight = worldViewLeft + canvas.width / camera.zoom;
                 const worldViewBottom = worldViewTop + canvas.height / camera.zoom;

                 // Calculate the first and last grid lines within the view
                 const firstGridX = Math.floor(worldViewLeft / TILE_SIZE) * TILE_SIZE;
                 const firstGridY = Math.floor(worldViewTop / TILE_SIZE) * TILE_SIZE;

                 const lastGridX = Math.ceil(worldViewRight / TILE_SIZE) * TILE_SIZE;
                 const lastGridY = Math.ceil(worldViewBottom / TILE_SIZE) * TILE_SIZE;


                 // Draw vertical lines in world coordinates
                 for (let x = firstGridX; x <= lastGridX; x += TILE_SIZE) {
                     ctx.beginPath();
                     ctx.moveTo(x, worldViewTop); // Start line at the top of the view
                     ctx.lineTo(x, worldViewBottom); // End line at the bottom of the view
                     ctx.stroke();
                 }

                 // Draw horizontal lines in world coordinates
                 for (let y = firstGridY; y <= lastGridY; y += TILE_SIZE) {
                     ctx.beginPath();
                     ctx.moveTo(worldViewLeft, y); // Start line at the left of the view
                     ctx.lineTo(worldViewRight, y); // End line at the right of the view
                     ctx.stroke();
                 }
            }


            function render() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Save context state
                ctx.save();

                // Apply camera transformations (pan and zoom)
                // The order matters: translate to center, scale, translate back, then apply pan.
                // This makes zooming happen towards the center of the canvas initially,
                // then panning shifts that view.
                // A common alternative is to translate by the center, scale, translate back
                // and *then* translate by -camera.x, -camera.y *before* scaling.
                // Let's try the standard zoom-to-center approach:
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(-canvas.width / 2, -canvas.height / 2);

                // Now, apply the camera pan *in world coordinates*
                ctx.translate(-camera.x, -camera.y);


                // Draw grid (now drawn in world coordinates)
                drawGrid();

                // Draw map objects (also drawn in world coordinates)
                mapObjects.forEach(obj => {
                    // Optional: Check if object is within the visible viewport before drawing for performance
                     const worldViewLeft = camera.x;
                     const worldViewTop = camera.y;
                     const worldViewRight = worldViewLeft + canvas.width / camera.zoom;
                     const worldViewBottom = worldViewTop + canvas.height / camera.zoom;

                     if (obj.x + obj.img.width > worldViewLeft &&
                         obj.y + obj.img.height > worldViewTop &&
                         obj.x < worldViewRight &&
                         obj.y < worldViewBottom) {
                          ctx.drawImage(obj.img, obj.x, obj.y);
                     }
                });

                // Draw selection box for selected map object
                if (selectedMapObject) {
                    ctx.strokeStyle = '#00aaff';
                    // Line width needs to scale inversely to zoom to appear consistent thickness on screen
                    ctx.lineWidth = 2 / camera.zoom;
                    // Draw the rectangle in world coordinates
                    ctx.strokeRect(selectedMapObject.x, selectedMapObject.y, selectedMapObject.img.width, selectedMapObject.img.height);
                }

                // Restore context state (removes all transformations)
                ctx.restore();

                // Request the next frame
                requestAnimationFrame(render);
            }

            // Start the render loop
            render();

            // --- Pan functionality ---
            let isPanning = false;
            let lastMousePos = { x: 0, y: 0 };

            // --- Map data & Inspector ---
            let mapObjects = [];
            let selectedMapObject = null;
            const inspectorPanel = document.getElementById('inspector-panel');

            function updateInspector() {
                // Clear existing content except the heading
                 inspectorPanel.innerHTML = '<h3>Inspector</h3>'; // Reset to just the heading

                if (selectedMapObject) {
                    // Add object details
                    const objectDetails = document.createElement('div');
                    objectDetails.innerHTML = `
                        <p><strong>Object:</strong> ${selectedMapObject.img.title}</p>
                        <p><strong>X:</strong> ${selectedMapObject.x}</p>
                        <p><strong>Y:</strong> ${selectedMapObject.y}</p>
                    `;
                    inspectorPanel.appendChild(objectDetails);

                    // Add delete button
                    const deleteButton = document.createElement('button');
                    deleteButton.id = 'delete-object-btn';
                    deleteButton.textContent = 'Delete Object';
                    inspectorPanel.appendChild(deleteButton);

                    // Add event listener to the *newly created* delete button
                    document.getElementById('delete-object-btn').addEventListener('click', () => {
                        mapObjects = mapObjects.filter(obj => obj !== selectedMapObject);
                        selectedMapObject = null; // Deselect the deleted object
                        updateInspector(); // Update inspector after deletion
                    });
                } else {
                    // If no object is selected, show placeholder text
                    const noObjectText = document.createElement('p');
                    noObjectText.textContent = 'No object selected.';
                     inspectorPanel.appendChild(noObjectText);
                }
            }

            // Initialize inspector state
            updateInspector();

            canvas.addEventListener('mousedown', (e) => {
                // Prevent default behavior like dragging images
                e.preventDefault();

                // Get mouse position relative to the canvas element
                const mouseX_screen = e.offsetX;
                const mouseY_screen = e.offsetY;

                // Convert screen coordinates (after canvas transformations) to world coordinates
                // Reverse the canvas transformations:
                // screenX = (worldX - camera.x) * camera.zoom + canvas.width/2 * (1-camera.zoom)
                // screenY = (worldY - camera.y) * camera.zoom + canvas.height/2 * (1-camera.zoom)
                // Solving for worldX, worldY:
                const worldX = (mouseX_screen - canvas.width / 2 * (1 - camera.zoom)) / camera.zoom + camera.x;
                const worldY = (mouseY_screen - canvas.height / 2 * (1 - camera.zoom)) / camera.zoom + camera.y;


                if (e.button === 0) { // Left mouse button
                    if (selectedObject) {
                        // --- Place new object ---

                        // Snap to grid
                        const gridX = Math.floor(worldX / TILE_SIZE) * TILE_SIZE;
                        const gridY = Math.floor(worldY / TILE_SIZE) * TILE_SIZE;

                        // Ensure object image is loaded before placing
                        if (selectedObject.complete) {
                            const newObject = {
                                img: selectedObject, // Reference to the palette image element
                                x: gridX,
                                y: gridY
                            };
                            mapObjects.push(newObject);
                            // Deselect from palette after placing
                            selectedObject.classList.remove('selected');
                            selectedObject = null;
                        } else {
                             console.warn("Palette image not fully loaded, cannot place object.");
                             // Optionally provide user feedback that image isn't ready
                        }

                    } else {
                        // --- Select an existing object ---
                        selectedMapObject = null; // Deselect any previously selected map object
                        let objectClicked = false;

                        // Find the top-most object under the cursor by checking in reverse order
                        for (let i = mapObjects.length - 1; i >= 0; i--) {
                            const obj = mapObjects[i];
                            // Check if the mouse world coordinates are within the object's world bounds
                            if (worldX >= obj.x && worldX < obj.x + obj.img.width &&
                                worldY >= obj.y && worldY < obj.y + obj.img.height) {
                                selectedMapObject = obj;
                                objectClicked = true;
                                break; // Found the top-most object, stop searching
                            }
                        }

                        updateInspector(); // Update inspector based on new selection (or no selection)
                    }
                } else if (e.button === 1) { // Middle mouse button for panning
                    isPanning = true;
                    // Use screen coordinates for tracking pan distance
                    lastMousePos = { x: e.clientX, y: e.clientY };
                    canvas.style.cursor = 'grabbing';
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                 e.preventDefault(); // Prevent default drag behaviors

                if (isPanning) {
                    const currentMouseX = e.clientX;
                    const currentMouseY = e.clientY;

                    // Calculate the delta in screen coordinates
                    const dx_screen = currentMouseX - lastMousePos.x;
                    const dy_screen = currentMouseY - lastMousePos.y;

                    // Update camera position. Panning should move the camera by the screen delta
                    // divided by the current zoom level to move the world under the cursor.
                    camera.x -= dx_screen / camera.zoom;
                    camera.y -= dy_screen / camera.zoom;

                    lastMousePos = { x: currentMouseX, y: currentMouseY };
                } else if (selectedObject) {
                    // Optional: Add a visual indicator (like a ghost image) following the cursor
                    // when an object is selected from the palette, before placing it.
                    // This would involve drawing the ghost image in the render loop.
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 1) {
                    isPanning = false;
                    canvas.style.cursor = 'default';
                }
            });

            canvas.addEventListener('mouseleave', () => {
                // If mouse leaves the canvas while panning, stop panning
                isPanning = false;
                canvas.style.cursor = 'default';
            });

             // --- Zoom functionality ---
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();

                const zoomSpeed = 0.1;
                const oldZoom = camera.zoom;

                // Calculate the new zoom level
                if (e.deltaY < 0) { // Scroll up zooms in
                    camera.zoom *= (1 + zoomSpeed);
                } else { // Scroll down zooms out
                    camera.zoom /= (1 + zoomSpeed);
                }

                // Clamp zoom level within a reasonable range
                camera.zoom = Math.max(0.1, Math.min(camera.zoom, 10)); // Min zoom 0.1, Max zoom 10

                // --- Adjust camera position to zoom towards the mouse pointer ---
                // Get mouse position relative to canvas in screen coordinates
                const mouseX_screen = e.offsetX;
                const mouseY_screen = e.offsetY;

                // Calculate the world coordinates of the mouse *before* zooming
                const mouseX_world_before = (mouseX_screen - canvas.width / 2 * (1 - oldZoom)) / oldZoom + camera.x;
                const mouseY_world_before = (mouseY_screen - canvas.height / 2 * (1 - oldZoom)) / oldZoom + camera.y;

                // Calculate the world coordinates of the mouse *after* zooming
                const mouseX_world_after = (mouseX_screen - canvas.width / 2 * (1 - camera.zoom)) / camera.zoom + camera.x;
                const mouseY_world_after = (mouseY_screen - canvas.height / 2 * (1 - camera.zoom)) / camera.zoom + camera.y;

                // Adjust the camera position so the point under the mouse in world coordinates
                // remains the same after zooming. The camera needs to shift by the difference
                // in the world coordinates of the mouse before and after the zoom.
                camera.x -= (mouseX_world_after - mouseX_world_before);
                camera.y -= (mouseY_world_after - mouseY_world_before);

            });

            // --- Keyboard shortcuts ---
            window.addEventListener('keydown', (e) => {
                // Check if the event target is NOT an input field or textarea to prevent accidental deletion
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                    if (e.key === 'Delete' && selectedMapObject) {
                        mapObjects = mapObjects.filter(obj => obj !== selectedMapObject);
                        selectedMapObject = null;
                        updateInspector(); // Update inspector after deletion
                        // Optional: Prevent default delete behavior if it exists for other elements
                        // e.preventDefault();
                    }
                }
            });

            // --- Save/Load functionality ---
            const saveBtn = document.getElementById('save-btn');
            const loadBtn = document.getElementById('load-btn');
            const loadInput = document.getElementById('load-input');

            saveBtn.addEventListener('click', () => {
                // Create map data structure for saving
                const mapData = mapObjects.map(obj => ({
                    // Extract path relative to 'maps/' for portability
                    // Ensure the obj.img.src actually contains '/maps/'
                    src: obj.img.src.includes('/maps/') ? obj.img.src.substring(obj.img.src.lastIndexOf('/maps/') + 1) : obj.img.src,
                    title: obj.img.title,
                    x: obj.x,
                    y: obj.y
                }));
                const json = JSON.stringify(mapData, null, 2); // Pretty-print JSON
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                // Create a temporary link to trigger download
                const a = document.createElement('a');
                a.href = url;
                a.download = 'map.map'; // Default filename
                document.body.appendChild(a); // Append to body to make it clickable in some browsers
                a.click(); // Trigger download
                document.body.removeChild(a); // Clean up the temporary link

                // Release the object URL
                URL.revokeObjectURL(url);
            });

            loadBtn.addEventListener('click', () => {
                // This triggers the hidden file input, opening the native file picker.
                // As discussed, creating a custom UI to *list local files* before selection is not possible.
                loadInput.click();
            });

            loadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return; // No file selected

                const reader = new FileReader();

                reader.onload = (event) => {
                    try {
                        const mapData = JSON.parse(event.target.result);

                        // Clear current map and selection
                        mapObjects = [];
                        selectedMapObject = null;
                        updateInspector();

                        // Load objects from file data
                        mapData.forEach(objData => {
                            const img = new Image();
                            img.title = objData.title; // Set title from saved data

                            // --- Important: Handle image source path during loading ---
                            // Assume saved 'src' is relative to the 'maps/' directory.
                            // You need to construct the correct path for your application.
                            // If your index.html is at the root, and maps are in a 'maps' folder:
                            img.src = 'maps/' + objData.src; // e.g., "maps/buildings.png"

                            // If your index.html is one level up from 'maps/':
                            // img.src = '../maps/' + objData.src; // e.g., "../maps/buildings.png"

                            // Make sure to handle image loading asynchronously
                            img.onload = () => {
                                // Only add the object to the mapObjects array once the image is loaded
                                const newObject = {
                                    img: img, // The loaded Image element
                                    x: objData.x,
                                    y: objData.y
                                };
                                mapObjects.push(newObject);
                                // No need to call render() here, requestAnimationFrame loop handles redraw
                            };
                            img.onerror = () => {
                                console.error("Failed to load image for object:", objData.src);
                                // Optionally add a placeholder or skip this object
                            };

                        });
                    } catch (error) {
                        console.error("Error loading map file:", error);
                        alert("Failed to load map file. Make sure it is a valid .map JSON file in the correct format.");
                    }
                };

                // Read the file content as text
                reader.readAsText(file);

                // Reset file input value so the same file can be selected and loaded again
                e.target.value = '';
            });

            // --- Object Palette ---
            const objectList = document.getElementById('object-list');
            let selectedObject = null; // Currently selected palette image

            // Define the objects available in the palette
            const objects = [
                // --- Important: Verify these paths match your project structure ---
                { name: 'Buildings', src: 'maps/buildings.png' },
                { name: 'Terrain', src: 'maps/firered_terrain.png' }
                // Add more objects here
            ];

            // Generate palette images
            objects.forEach(obj => {
                const img = new Image();
                img.src = obj.src;
                img.title = obj.name; // Use name as title (hover text)
                img.classList.add('palette-object');

                // Use onload to add the image to the palette only when loaded
                img.onload = () => {
                     objectList.appendChild(img);
                };

                 img.onerror = () => {
                     console.error("Failed to load palette image:", obj.src);
                     // Optionally add a broken image icon or skip this palette item
                 };


                // Add click listener to select the palette object
                img.addEventListener('click', () => {
                    // Deselect previously selected palette object
                    if (selectedObject && selectedObject !== img) {
                        selectedObject.classList.remove('selected');
                    }
                    // Toggle selection
                    if (selectedObject === img) {
                         selectedObject.classList.remove('selected');
                         selectedObject = null;
                    } else {
                         selectedObject = img;
                         selectedObject.classList.add('selected');
                    }
                     console.log("Selected object:", selectedObject ? selectedObject.title : "None");
                });
            });
        });
    </script>
</body>
</html>
